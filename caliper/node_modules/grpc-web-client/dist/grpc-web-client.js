(function(e, a) { for(var i in a) e[i] = a[i]; }(exports, /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// identity function for calling harmony imports with the correct context
/******/ 	__webpack_require__.i = function(value) { return value; };
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 17);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var browser_headers_1 = __webpack_require__(4);
exports.Metadata = browser_headers_1.BrowserHeaders;


/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
function debug() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
    }
    if (console.debug) {
        console.debug.apply(null, args);
    }
    else {
        console.log.apply(null, args);
    }
}
exports.debug = debug;


/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var awaitingExecution = null;
function runCallbacks() {
    if (awaitingExecution) {
        var thisCallbackSet = awaitingExecution;
        awaitingExecution = null;
        for (var i = 0; i < thisCallbackSet.length; i++) {
            try {
                thisCallbackSet[i]();
            }
            catch (e) {
                if (awaitingExecution === null) {
                    awaitingExecution = [];
                    setTimeout(function () {
                        runCallbacks();
                    }, 0);
                }
                for (var k = thisCallbackSet.length - 1; k > i; k--) {
                    awaitingExecution.unshift(thisCallbackSet[k]);
                }
                throw e;
            }
        }
    }
}
function detach(cb) {
    if (awaitingExecution !== null) {
        awaitingExecution.push(cb);
        return;
    }
    awaitingExecution = [cb];
    setTimeout(function () {
        runCallbacks();
    }, 0);
}
exports.default = detach;


/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var metadata_1 = __webpack_require__(0);
var ChunkParser_1 = __webpack_require__(10);
var Code_1 = __webpack_require__(5);
var debug_1 = __webpack_require__(1);
var detach_1 = __webpack_require__(2);
var Transport_1 = __webpack_require__(6);
var util_1 = __webpack_require__(19);
function client(methodDescriptor, props) {
    return new GrpcClient(methodDescriptor, props);
}
exports.client = client;
var GrpcClient = (function () {
    function GrpcClient(methodDescriptor, props) {
        this.started = false;
        this.sentFirstMessage = false;
        this.completed = false;
        this.closed = false;
        this.finishedSending = false;
        this.onHeadersCallbacks = [];
        this.onMessageCallbacks = [];
        this.onEndCallbacks = [];
        this.parser = new ChunkParser_1.ChunkParser();
        this.methodDefinition = methodDescriptor;
        this.props = props;
        this.createTransport();
    }
    GrpcClient.prototype.createTransport = function () {
        var url = this.props.host + "/" + this.methodDefinition.service.serviceName + "/" + this.methodDefinition.methodName;
        var transportOptions = {
            methodDefinition: this.methodDefinition,
            debug: this.props.debug || false,
            url: url,
            onHeaders: this.onTransportHeaders.bind(this),
            onChunk: this.onTransportChunk.bind(this),
            onEnd: this.onTransportEnd.bind(this),
        };
        if (this.props.transport) {
            this.transport = this.props.transport(transportOptions);
        }
        else {
            this.transport = Transport_1.makeDefaultTransport(transportOptions);
        }
    };
    GrpcClient.prototype.onTransportHeaders = function (headers, status) {
        this.props.debug && debug_1.debug("onHeaders", headers, status);
        if (this.closed) {
            this.props.debug && debug_1.debug("grpc.onHeaders received after request was closed - ignoring");
            return;
        }
        if (status === 0) {
        }
        else {
            this.responseHeaders = headers;
            this.props.debug && debug_1.debug("onHeaders.responseHeaders", JSON.stringify(this.responseHeaders, null, 2));
            var gRPCStatus = getStatusFromHeaders(headers);
            this.props.debug && debug_1.debug("onHeaders.gRPCStatus", gRPCStatus);
            var code = gRPCStatus && gRPCStatus >= 0 ? gRPCStatus : Code_1.httpStatusToCode(status);
            this.props.debug && debug_1.debug("onHeaders.code", code);
            var gRPCMessage = headers.get("grpc-message") || [];
            this.props.debug && debug_1.debug("onHeaders.gRPCMessage", gRPCMessage);
            this.rawOnHeaders(headers);
            if (code !== Code_1.Code.OK) {
                var statusMessage = this.decodeGRPCStatus(gRPCMessage[0]);
                this.rawOnError(code, statusMessage, headers);
            }
        }
    };
    GrpcClient.prototype.onTransportChunk = function (chunkBytes) {
        var _this = this;
        if (this.closed) {
            this.props.debug && debug_1.debug("grpc.onChunk received after request was closed - ignoring");
            return;
        }
        var data = [];
        try {
            data = this.parser.parse(chunkBytes);
        }
        catch (e) {
            this.props.debug && debug_1.debug("onChunk.parsing error", e, e.message);
            this.rawOnError(Code_1.Code.Internal, "parsing error: " + e.message);
            return;
        }
        data.forEach(function (d) {
            if (d.chunkType === ChunkParser_1.ChunkType.MESSAGE) {
                var deserialized = _this.methodDefinition.responseType.deserializeBinary(d.data);
                _this.rawOnMessage(deserialized);
            }
            else if (d.chunkType === ChunkParser_1.ChunkType.TRAILERS) {
                if (!_this.responseHeaders) {
                    _this.responseHeaders = new metadata_1.Metadata(d.trailers);
                    _this.rawOnHeaders(_this.responseHeaders);
                }
                else {
                    _this.responseTrailers = new metadata_1.Metadata(d.trailers);
                    _this.props.debug && debug_1.debug("onChunk.trailers", _this.responseTrailers);
                }
            }
        });
    };
    GrpcClient.prototype.onTransportEnd = function () {
        this.props.debug && debug_1.debug("grpc.onEnd");
        if (this.closed) {
            this.props.debug && debug_1.debug("grpc.onEnd received after request was closed - ignoring");
            return;
        }
        if (this.responseTrailers === undefined) {
            if (this.responseHeaders === undefined) {
                this.rawOnError(Code_1.Code.Unknown, "Response closed without headers");
                return;
            }
            var grpcStatus_1 = getStatusFromHeaders(this.responseHeaders);
            var grpcMessage_1 = this.responseHeaders.get("grpc-message");
            this.props.debug && debug_1.debug("grpc.headers only response ", grpcStatus_1, grpcMessage_1);
            if (grpcStatus_1 === null) {
                this.rawOnEnd(Code_1.Code.Unknown, "Response closed without grpc-status (Headers only)", this.responseHeaders);
                return;
            }
            var statusMessage_1 = this.decodeGRPCStatus(grpcMessage_1[0]);
            this.rawOnEnd(grpcStatus_1, statusMessage_1, this.responseHeaders);
            return;
        }
        var grpcStatus = getStatusFromHeaders(this.responseTrailers);
        if (grpcStatus === null) {
            this.rawOnError(Code_1.Code.Internal, "Response closed without grpc-status (Trailers provided)");
            return;
        }
        var grpcMessage = this.responseTrailers.get("grpc-message");
        var statusMessage = this.decodeGRPCStatus(grpcMessage[0]);
        this.rawOnEnd(grpcStatus, statusMessage, this.responseTrailers);
    };
    GrpcClient.prototype.decodeGRPCStatus = function (src) {
        if (src) {
            try {
                return decodeURIComponent(src);
            }
            catch (err) {
                return src;
            }
        }
        else {
            return "";
        }
    };
    GrpcClient.prototype.rawOnEnd = function (code, message, trailers) {
        var _this = this;
        this.props.debug && debug_1.debug("rawOnEnd", code, message, trailers);
        if (this.completed)
            return;
        this.completed = true;
        this.onEndCallbacks.forEach(function (callback) {
            detach_1.default(function () {
                if (_this.closed)
                    return;
                callback(code, message, trailers);
            });
        });
    };
    GrpcClient.prototype.rawOnHeaders = function (headers) {
        this.props.debug && debug_1.debug("rawOnHeaders", headers);
        if (this.completed)
            return;
        this.onHeadersCallbacks.forEach(function (callback) {
            detach_1.default(function () {
                callback(headers);
            });
        });
    };
    GrpcClient.prototype.rawOnError = function (code, msg, trailers) {
        var _this = this;
        if (trailers === void 0) { trailers = new metadata_1.Metadata(); }
        this.props.debug && debug_1.debug("rawOnError", code, msg);
        if (this.completed)
            return;
        this.completed = true;
        this.onEndCallbacks.forEach(function (callback) {
            detach_1.default(function () {
                if (_this.closed)
                    return;
                callback(code, msg, trailers);
            });
        });
    };
    GrpcClient.prototype.rawOnMessage = function (res) {
        var _this = this;
        this.props.debug && debug_1.debug("rawOnMessage", res.toObject());
        if (this.completed || this.closed)
            return;
        this.onMessageCallbacks.forEach(function (callback) {
            detach_1.default(function () {
                if (_this.closed)
                    return;
                callback(res);
            });
        });
    };
    GrpcClient.prototype.onHeaders = function (callback) {
        this.onHeadersCallbacks.push(callback);
    };
    GrpcClient.prototype.onMessage = function (callback) {
        this.onMessageCallbacks.push(callback);
    };
    GrpcClient.prototype.onEnd = function (callback) {
        this.onEndCallbacks.push(callback);
    };
    GrpcClient.prototype.start = function (metadata) {
        if (this.started) {
            throw new Error("Client already started - cannot .start()");
        }
        this.started = true;
        var requestHeaders = new metadata_1.Metadata(metadata ? metadata : {});
        requestHeaders.set("content-type", "application/grpc-web+proto");
        requestHeaders.set("x-grpc-web", "1");
        this.transport.start(requestHeaders);
    };
    GrpcClient.prototype.send = function (msg) {
        if (!this.started) {
            throw new Error("Client not started - .start() must be called before .send()");
        }
        if (this.closed) {
            throw new Error("Client already closed - cannot .send()");
        }
        if (this.finishedSending) {
            throw new Error("Client already finished sending - cannot .send()");
        }
        if (!this.methodDefinition.requestStream && this.sentFirstMessage) {
            throw new Error("Message already sent for non-client-streaming method - cannot .send()");
        }
        this.sentFirstMessage = true;
        var msgBytes = util_1.frameRequest(msg);
        this.transport.sendMessage(msgBytes);
    };
    GrpcClient.prototype.finishSend = function () {
        if (!this.started) {
            throw new Error("Client not started - .finishSend() must be called before .close()");
        }
        if (this.closed) {
            throw new Error("Client already closed - cannot .send()");
        }
        if (this.finishedSending) {
            throw new Error("Client already finished sending - cannot .finishSend()");
        }
        this.finishedSending = true;
        this.transport.finishSend();
    };
    GrpcClient.prototype.close = function () {
        if (!this.started) {
            throw new Error("Client not started - .start() must be called before .close()");
        }
        if (!this.closed) {
            this.closed = true;
            this.props.debug && debug_1.debug("request.abort aborting request");
            this.transport.cancel();
        }
        else {
            throw new Error("Client already closed - cannot .close()");
        }
    };
    return GrpcClient;
}());
function getStatusFromHeaders(headers) {
    var fromHeaders = headers.get("grpc-status") || [];
    if (fromHeaders.length > 0) {
        try {
            var asString = fromHeaders[0];
            return parseInt(asString, 10);
        }
        catch (e) {
            return null;
        }
    }
    return null;
}


/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var BrowserHeaders_1 = __webpack_require__(14);
exports.BrowserHeaders = BrowserHeaders_1.BrowserHeaders;
//# sourceMappingURL=index.js.map

/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var Code;
(function (Code) {
    Code[Code["OK"] = 0] = "OK";
    Code[Code["Canceled"] = 1] = "Canceled";
    Code[Code["Unknown"] = 2] = "Unknown";
    Code[Code["InvalidArgument"] = 3] = "InvalidArgument";
    Code[Code["DeadlineExceeded"] = 4] = "DeadlineExceeded";
    Code[Code["NotFound"] = 5] = "NotFound";
    Code[Code["AlreadyExists"] = 6] = "AlreadyExists";
    Code[Code["PermissionDenied"] = 7] = "PermissionDenied";
    Code[Code["ResourceExhausted"] = 8] = "ResourceExhausted";
    Code[Code["FailedPrecondition"] = 9] = "FailedPrecondition";
    Code[Code["Aborted"] = 10] = "Aborted";
    Code[Code["OutOfRange"] = 11] = "OutOfRange";
    Code[Code["Unimplemented"] = 12] = "Unimplemented";
    Code[Code["Internal"] = 13] = "Internal";
    Code[Code["Unavailable"] = 14] = "Unavailable";
    Code[Code["DataLoss"] = 15] = "DataLoss";
    Code[Code["Unauthenticated"] = 16] = "Unauthenticated";
})(Code = exports.Code || (exports.Code = {}));
function httpStatusToCode(httpStatus) {
    switch (httpStatus) {
        case 0:
            return Code.Internal;
        case 200:
            return Code.OK;
        case 400:
            return Code.InvalidArgument;
        case 401:
            return Code.Unauthenticated;
        case 403:
            return Code.PermissionDenied;
        case 404:
            return Code.NotFound;
        case 409:
            return Code.Aborted;
        case 412:
            return Code.FailedPrecondition;
        case 429:
            return Code.ResourceExhausted;
        case 499:
            return Code.Canceled;
        case 500:
            return Code.Unknown;
        case 501:
            return Code.Unimplemented;
        case 503:
            return Code.Unavailable;
        case 504:
            return Code.DeadlineExceeded;
        default:
            return Code.Unknown;
    }
}
exports.httpStatusToCode = httpStatusToCode;


/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var http_1 = __webpack_require__(8);
var defaultTransportFactory = function (options) { return http_1.CrossBrowserHttpTransport({ withCredentials: false })(options); };
function setDefaultTransportFactory(t) {
    defaultTransportFactory = t;
}
exports.setDefaultTransportFactory = setDefaultTransportFactory;
function makeDefaultTransport(options) {
    return defaultTransportFactory(options);
}
exports.makeDefaultTransport = makeDefaultTransport;


/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", { value: true });
var metadata_1 = __webpack_require__(0);
var debug_1 = __webpack_require__(1);
var detach_1 = __webpack_require__(2);
function FetchReadableStreamTransport(init) {
    return function (opts) {
        return fetchRequest(opts, init);
    };
}
exports.FetchReadableStreamTransport = FetchReadableStreamTransport;
function fetchRequest(options, init) {
    options.debug && debug_1.debug("fetchRequest", options);
    return new Fetch(options, init);
}
var Fetch = (function () {
    function Fetch(transportOptions, init) {
        this.cancelled = false;
        this.controller = window.AbortController && new AbortController();
        this.options = transportOptions;
        this.init = init;
    }
    Fetch.prototype.pump = function (readerArg, res) {
        var _this = this;
        this.reader = readerArg;
        if (this.cancelled) {
            this.options.debug && debug_1.debug("Fetch.pump.cancel at first pump");
            this.reader.cancel();
            return;
        }
        this.reader.read()
            .then(function (result) {
            if (result.done) {
                detach_1.default(function () {
                    _this.options.onEnd();
                });
                return res;
            }
            detach_1.default(function () {
                _this.options.onChunk(result.value);
            });
            _this.pump(_this.reader, res);
            return;
        })
            .catch(function (err) {
            if (_this.cancelled) {
                _this.options.debug && debug_1.debug("Fetch.catch - request cancelled");
                return;
            }
            _this.cancelled = true;
            _this.options.debug && debug_1.debug("Fetch.catch", err.message);
            detach_1.default(function () {
                _this.options.onEnd(err);
            });
        });
    };
    Fetch.prototype.send = function (msgBytes) {
        var _this = this;
        fetch(this.options.url, __assign({}, this.init, { headers: this.metadata.toHeaders(), method: "POST", body: msgBytes, signal: this.controller && this.controller.signal })).then(function (res) {
            _this.options.debug && debug_1.debug("Fetch.response", res);
            detach_1.default(function () {
                _this.options.onHeaders(new metadata_1.Metadata(res.headers), res.status);
            });
            if (res.body) {
                _this.pump(res.body.getReader(), res);
                return;
            }
            return res;
        }).catch(function (err) {
            if (_this.cancelled) {
                _this.options.debug && debug_1.debug("Fetch.catch - request cancelled");
                return;
            }
            _this.cancelled = true;
            _this.options.debug && debug_1.debug("Fetch.catch", err.message);
            detach_1.default(function () {
                _this.options.onEnd(err);
            });
        });
    };
    Fetch.prototype.sendMessage = function (msgBytes) {
        this.send(msgBytes);
    };
    Fetch.prototype.finishSend = function () {
    };
    Fetch.prototype.start = function (metadata) {
        this.metadata = metadata;
    };
    Fetch.prototype.cancel = function () {
        if (this.cancelled) {
            this.options.debug && debug_1.debug("Fetch.abort.cancel already cancelled");
            return;
        }
        this.cancelled = true;
        if (this.reader) {
            this.options.debug && debug_1.debug("Fetch.abort.cancel");
            this.reader.cancel();
        }
        else {
            this.options.debug && debug_1.debug("Fetch.abort.cancel before reader");
        }
        if (this.controller) {
            this.controller.abort();
        }
    };
    return Fetch;
}());
function detectFetchSupport() {
    return typeof Response !== "undefined" && Response.prototype.hasOwnProperty("body") && typeof Headers === "function";
}
exports.detectFetchSupport = detectFetchSupport;


/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var fetch_1 = __webpack_require__(7);
var xhr_1 = __webpack_require__(9);
function CrossBrowserHttpTransport(init) {
    if (fetch_1.detectFetchSupport()) {
        var fetchInit = {
            credentials: init.withCredentials ? "include" : "same-origin"
        };
        return fetch_1.FetchReadableStreamTransport(fetchInit);
    }
    return xhr_1.XhrTransport({ withCredentials: init.withCredentials });
}
exports.CrossBrowserHttpTransport = CrossBrowserHttpTransport;


/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var metadata_1 = __webpack_require__(0);
var debug_1 = __webpack_require__(1);
var detach_1 = __webpack_require__(2);
var xhrUtil_1 = __webpack_require__(18);
function XhrTransport(init) {
    return function (opts) {
        if (xhrUtil_1.detectMozXHRSupport()) {
            return new MozChunkedArrayBufferXHR(opts, init);
        }
        else if (xhrUtil_1.detectXHROverrideMimeTypeSupport()) {
            return new XHR(opts, init);
        }
        else {
            throw new Error("This environment's XHR implementation cannot support binary transfer.");
        }
    };
}
exports.XhrTransport = XhrTransport;
var XHR = (function () {
    function XHR(transportOptions, init) {
        this.options = transportOptions;
        this.init = init;
    }
    XHR.prototype.onProgressEvent = function () {
        var _this = this;
        this.options.debug && debug_1.debug("XHR.onProgressEvent.length: ", this.xhr.response.length);
        var rawText = this.xhr.response.substr(this.index);
        this.index = this.xhr.response.length;
        var asArrayBuffer = stringToArrayBuffer(rawText);
        detach_1.default(function () {
            _this.options.onChunk(asArrayBuffer);
        });
    };
    XHR.prototype.onLoadEvent = function () {
        var _this = this;
        this.options.debug && debug_1.debug("XHR.onLoadEvent");
        detach_1.default(function () {
            _this.options.onEnd();
        });
    };
    XHR.prototype.onStateChange = function () {
        var _this = this;
        this.options.debug && debug_1.debug("XHR.onStateChange", this.xhr.readyState);
        if (this.xhr.readyState === XMLHttpRequest.HEADERS_RECEIVED) {
            detach_1.default(function () {
                _this.options.onHeaders(new metadata_1.Metadata(_this.xhr.getAllResponseHeaders()), _this.xhr.status);
            });
        }
    };
    XHR.prototype.sendMessage = function (msgBytes) {
        this.xhr.send(msgBytes);
    };
    XHR.prototype.finishSend = function () {
    };
    XHR.prototype.start = function (metadata) {
        var _this = this;
        this.metadata = metadata;
        var xhr = new XMLHttpRequest();
        this.xhr = xhr;
        xhr.open("POST", this.options.url);
        this.configureXhr();
        this.metadata.forEach(function (key, values) {
            xhr.setRequestHeader(key, values.join(", "));
        });
        xhr.withCredentials = Boolean(this.init.withCredentials);
        xhr.addEventListener("readystatechange", this.onStateChange.bind(this));
        xhr.addEventListener("progress", this.onProgressEvent.bind(this));
        xhr.addEventListener("loadend", this.onLoadEvent.bind(this));
        xhr.addEventListener("error", function (err) {
            _this.options.debug && debug_1.debug("XHR.error", err);
            detach_1.default(function () {
                _this.options.onEnd(err.error);
            });
        });
    };
    XHR.prototype.configureXhr = function () {
        this.xhr.responseType = "text";
        this.xhr.overrideMimeType("text/plain; charset=x-user-defined");
    };
    XHR.prototype.cancel = function () {
        this.options.debug && debug_1.debug("XHR.abort");
        this.xhr.abort();
    };
    return XHR;
}());
exports.XHR = XHR;
var MozChunkedArrayBufferXHR = (function (_super) {
    __extends(MozChunkedArrayBufferXHR, _super);
    function MozChunkedArrayBufferXHR() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    MozChunkedArrayBufferXHR.prototype.configureXhr = function () {
        this.options.debug && debug_1.debug("MozXHR.configureXhr: setting responseType to 'moz-chunked-arraybuffer'");
        this.xhr.responseType = "moz-chunked-arraybuffer";
    };
    MozChunkedArrayBufferXHR.prototype.onProgressEvent = function () {
        var _this = this;
        var resp = this.xhr.response;
        this.options.debug && debug_1.debug("MozXHR.onProgressEvent: ", new Uint8Array(resp));
        detach_1.default(function () {
            _this.options.onChunk(new Uint8Array(resp));
        });
    };
    return MozChunkedArrayBufferXHR;
}(XHR));
exports.MozChunkedArrayBufferXHR = MozChunkedArrayBufferXHR;
function codePointAtPolyfill(str, index) {
    var code = str.charCodeAt(index);
    if (code >= 0xd800 && code <= 0xdbff) {
        var surr = str.charCodeAt(index + 1);
        if (surr >= 0xdc00 && surr <= 0xdfff) {
            code = 0x10000 + ((code - 0xd800) << 10) + (surr - 0xdc00);
        }
    }
    return code;
}
function stringToArrayBuffer(str) {
    var asArray = new Uint8Array(str.length);
    var arrayIndex = 0;
    for (var i = 0; i < str.length; i++) {
        var codePoint = String.prototype.codePointAt ? str.codePointAt(i) : codePointAtPolyfill(str, i);
        asArray[arrayIndex++] = codePoint & 0xFF;
    }
    return asArray;
}
exports.stringToArrayBuffer = stringToArrayBuffer;


/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var metadata_1 = __webpack_require__(0);
var HEADER_SIZE = 5;
var isAllowedControlChars = function (char) { return char === 0x9 || char === 0xa || char === 0xd; };
function isValidHeaderAscii(val) {
    return isAllowedControlChars(val) || (val >= 0x20 && val <= 0x7e);
}
function decodeASCII(input) {
    for (var i = 0; i !== input.length; ++i) {
        if (!isValidHeaderAscii(input[i])) {
            throw new Error("Metadata is not valid (printable) ASCII");
        }
    }
    return String.fromCharCode.apply(String, Array.prototype.slice.call(input));
}
exports.decodeASCII = decodeASCII;
function encodeASCII(input) {
    var encoded = new Uint8Array(input.length);
    for (var i = 0; i !== input.length; ++i) {
        var charCode = input.charCodeAt(i);
        if (!isValidHeaderAscii(charCode)) {
            throw new Error("Metadata contains invalid ASCII");
        }
        encoded[i] = charCode;
    }
    return encoded;
}
exports.encodeASCII = encodeASCII;
function isTrailerHeader(headerView) {
    return (headerView.getUint8(0) & 0x80) === 0x80;
}
function parseTrailerData(msgData) {
    return new metadata_1.Metadata(decodeASCII(msgData));
}
function readLengthFromHeader(headerView) {
    return headerView.getUint32(1, false);
}
function hasEnoughBytes(buffer, position, byteCount) {
    return buffer.byteLength - position >= byteCount;
}
function sliceUint8Array(buffer, from, to) {
    if (buffer.slice) {
        return buffer.slice(from, to);
    }
    var end = buffer.length;
    if (to !== undefined) {
        end = to;
    }
    var num = end - from;
    var array = new Uint8Array(num);
    var arrayIndex = 0;
    for (var i = from; i < end; i++) {
        array[arrayIndex++] = buffer[i];
    }
    return array;
}
var ChunkType;
(function (ChunkType) {
    ChunkType[ChunkType["MESSAGE"] = 1] = "MESSAGE";
    ChunkType[ChunkType["TRAILERS"] = 2] = "TRAILERS";
})(ChunkType = exports.ChunkType || (exports.ChunkType = {}));
var ChunkParser = (function () {
    function ChunkParser() {
        this.buffer = null;
        this.position = 0;
    }
    ChunkParser.prototype.parse = function (bytes, flush) {
        if (bytes.length === 0 && flush) {
            return [];
        }
        var chunkData = [];
        if (this.buffer == null) {
            this.buffer = bytes;
            this.position = 0;
        }
        else if (this.position === this.buffer.byteLength) {
            this.buffer = bytes;
            this.position = 0;
        }
        else {
            var remaining = this.buffer.byteLength - this.position;
            var newBuf = new Uint8Array(remaining + bytes.byteLength);
            var fromExisting = sliceUint8Array(this.buffer, this.position);
            newBuf.set(fromExisting, 0);
            var latestDataBuf = new Uint8Array(bytes);
            newBuf.set(latestDataBuf, remaining);
            this.buffer = newBuf;
            this.position = 0;
        }
        while (true) {
            if (!hasEnoughBytes(this.buffer, this.position, HEADER_SIZE)) {
                return chunkData;
            }
            var headerBuffer = sliceUint8Array(this.buffer, this.position, this.position + HEADER_SIZE);
            var headerView = new DataView(headerBuffer.buffer, headerBuffer.byteOffset, headerBuffer.byteLength);
            var msgLength = readLengthFromHeader(headerView);
            if (!hasEnoughBytes(this.buffer, this.position, HEADER_SIZE + msgLength)) {
                return chunkData;
            }
            var messageData = sliceUint8Array(this.buffer, this.position + HEADER_SIZE, this.position + HEADER_SIZE + msgLength);
            this.position += HEADER_SIZE + msgLength;
            if (isTrailerHeader(headerView)) {
                chunkData.push({ chunkType: ChunkType.TRAILERS, trailers: parseTrailerData(messageData) });
                return chunkData;
            }
            else {
                chunkData.push({ chunkType: ChunkType.MESSAGE, data: messageData });
            }
        }
    };
    return ChunkParser;
}());
exports.ChunkParser = ChunkParser;


/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var client_1 = __webpack_require__(3);
function invoke(methodDescriptor, props) {
    if (methodDescriptor.requestStream) {
        throw new Error(".invoke cannot be used with client-streaming methods. Use .client instead.");
    }
    var grpcClient = client_1.client(methodDescriptor, {
        host: props.host,
        transport: props.transport,
        debug: props.debug,
    });
    if (props.onHeaders) {
        grpcClient.onHeaders(props.onHeaders);
    }
    if (props.onMessage) {
        grpcClient.onMessage(props.onMessage);
    }
    if (props.onEnd) {
        grpcClient.onEnd(props.onEnd);
    }
    grpcClient.start(props.metadata);
    grpcClient.send(props.request);
    grpcClient.finishSend();
    return {
        close: function () {
            grpcClient.close();
        }
    };
}
exports.invoke = invoke;


/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var debug_1 = __webpack_require__(1);
var detach_1 = __webpack_require__(2);
var ChunkParser_1 = __webpack_require__(10);
var WebsocketSignal;
(function (WebsocketSignal) {
    WebsocketSignal[WebsocketSignal["FINISH_SEND"] = 1] = "FINISH_SEND";
})(WebsocketSignal || (WebsocketSignal = {}));
var finishSendFrame = new Uint8Array([1]);
function WebsocketTransport() {
    return function (opts) {
        return websocketRequest(opts);
    };
}
exports.WebsocketTransport = WebsocketTransport;
function websocketRequest(options) {
    options.debug && debug_1.debug("websocketRequest", options);
    var webSocketAddress = constructWebSocketAddress(options.url);
    var sendQueue = [];
    var ws;
    function sendToWebsocket(toSend) {
        if (toSend === WebsocketSignal.FINISH_SEND) {
            ws.send(finishSendFrame);
        }
        else {
            var byteArray = toSend;
            var c = new Int8Array(byteArray.byteLength + 1);
            c.set(new Uint8Array([0]));
            c.set(byteArray, 1);
            ws.send(c);
        }
    }
    return {
        sendMessage: function (msgBytes) {
            if (!ws || ws.readyState === ws.CONNECTING) {
                sendQueue.push(msgBytes);
            }
            else {
                sendToWebsocket(msgBytes);
            }
        },
        finishSend: function () {
            if (!ws || ws.readyState === ws.CONNECTING) {
                sendQueue.push(WebsocketSignal.FINISH_SEND);
            }
            else {
                sendToWebsocket(WebsocketSignal.FINISH_SEND);
            }
        },
        start: function (metadata) {
            ws = new WebSocket(webSocketAddress, ["grpc-websockets"]);
            ws.binaryType = "arraybuffer";
            ws.onopen = function () {
                options.debug && debug_1.debug("websocketRequest.onopen");
                ws.send(headersToBytes(metadata));
                sendQueue.forEach(function (toSend) {
                    sendToWebsocket(toSend);
                });
            };
            ws.onclose = function (closeEvent) {
                options.debug && debug_1.debug("websocketRequest.onclose", closeEvent);
                detach_1.default(function () {
                    options.onEnd();
                });
            };
            ws.onerror = function (error) {
                options.debug && debug_1.debug("websocketRequest.onerror", error);
            };
            ws.onmessage = function (e) {
                detach_1.default(function () {
                    options.onChunk(new Uint8Array(e.data));
                });
            };
        },
        cancel: function () {
            options.debug && debug_1.debug("websocket.abort");
            detach_1.default(function () {
                ws.close();
            });
        }
    };
}
function constructWebSocketAddress(url) {
    if (url.substr(0, 8) === "https://") {
        return "wss://" + url.substr(8);
    }
    else if (url.substr(0, 7) === "http://") {
        return "ws://" + url.substr(7);
    }
    throw new Error("Websocket transport constructed with non-https:// or http:// host.");
}
function headersToBytes(headers) {
    var asString = "";
    headers.forEach(function (key, values) {
        asString += key + ": " + values.join(", ") + "\r\n";
    });
    return ChunkParser_1.encodeASCII(asString);
}


/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var metadata_1 = __webpack_require__(0);
var client_1 = __webpack_require__(3);
function unary(methodDescriptor, props) {
    if (methodDescriptor.responseStream) {
        throw new Error(".unary cannot be used with server-streaming methods. Use .invoke or .client instead.");
    }
    if (methodDescriptor.requestStream) {
        throw new Error(".unary cannot be used with client-streaming methods. Use .client instead.");
    }
    var responseHeaders = null;
    var responseMessage = null;
    var grpcClient = client_1.client(methodDescriptor, {
        host: props.host,
        transport: props.transport,
        debug: props.debug,
    });
    grpcClient.onHeaders(function (headers) {
        responseHeaders = headers;
    });
    grpcClient.onMessage(function (res) {
        responseMessage = res;
    });
    grpcClient.onEnd(function (status, statusMessage, trailers) {
        props.onEnd({
            status: status,
            statusMessage: statusMessage,
            headers: responseHeaders ? responseHeaders : new metadata_1.Metadata(),
            message: responseMessage,
            trailers: trailers
        });
    });
    grpcClient.start(props.metadata);
    grpcClient.send(props.request);
    grpcClient.finishSend();
    return {
        close: function () {
            grpcClient.close();
        }
    };
}
exports.unary = unary;


/***/ }),
/* 14 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var util_1 = __webpack_require__(16);
function isBrowserHeaders(arg) {
    return typeof arg === "object" && typeof arg.headersMap === "object" && typeof arg.forEach === "function";
}
var BrowserHeaders = (function () {
    function BrowserHeaders(init, options) {
        if (init === void 0) { init = {}; }
        if (options === void 0) { options = { splitValues: false }; }
        var _this = this;
        this.headersMap = {};
        if (init) {
            if (typeof Headers !== "undefined" && init instanceof Headers) {
                var keys = util_1.getHeaderKeys(init);
                keys.forEach(function (key) {
                    var values = util_1.getHeaderValues(init, key);
                    values.forEach(function (value) {
                        if (options.splitValues) {
                            _this.append(key, util_1.splitHeaderValue(value));
                        }
                        else {
                            _this.append(key, value);
                        }
                    });
                });
            }
            else if (isBrowserHeaders(init)) {
                init.forEach(function (key, values) {
                    _this.append(key, values);
                });
            }
            else if (typeof Map !== "undefined" && init instanceof Map) {
                var asMap = init;
                asMap.forEach(function (value, key) {
                    _this.append(key, value);
                });
            }
            else if (typeof init === "string") {
                this.appendFromString(init);
            }
            else if (typeof init === "object") {
                Object.getOwnPropertyNames(init).forEach(function (key) {
                    var asObject = init;
                    var values = asObject[key];
                    if (Array.isArray(values)) {
                        values.forEach(function (value) {
                            _this.append(key, value);
                        });
                    }
                    else {
                        _this.append(key, values);
                    }
                });
            }
        }
    }
    BrowserHeaders.prototype.appendFromString = function (str) {
        var pairs = str.split("\r\n");
        for (var i = 0; i < pairs.length; i++) {
            var p = pairs[i];
            var index = p.indexOf(":");
            if (index > 0) {
                var key = p.substring(0, index).trim();
                var value = p.substring(index + 1).trim();
                this.append(key, value);
            }
        }
    };
    BrowserHeaders.prototype.delete = function (key, value) {
        var normalizedKey = util_1.normalizeName(key);
        if (value === undefined) {
            delete this.headersMap[normalizedKey];
        }
        else {
            var existing = this.headersMap[normalizedKey];
            if (existing) {
                var index = existing.indexOf(value);
                if (index >= 0) {
                    existing.splice(index, 1);
                }
                if (existing.length === 0) {
                    delete this.headersMap[normalizedKey];
                }
            }
        }
    };
    BrowserHeaders.prototype.append = function (key, value) {
        var _this = this;
        var normalizedKey = util_1.normalizeName(key);
        if (!Array.isArray(this.headersMap[normalizedKey])) {
            this.headersMap[normalizedKey] = [];
        }
        if (Array.isArray(value)) {
            value.forEach(function (arrayValue) {
                _this.headersMap[normalizedKey].push(util_1.normalizeValue(arrayValue));
            });
        }
        else {
            this.headersMap[normalizedKey].push(util_1.normalizeValue(value));
        }
    };
    BrowserHeaders.prototype.set = function (key, value) {
        var normalizedKey = util_1.normalizeName(key);
        if (Array.isArray(value)) {
            var normalized_1 = [];
            value.forEach(function (arrayValue) {
                normalized_1.push(util_1.normalizeValue(arrayValue));
            });
            this.headersMap[normalizedKey] = normalized_1;
        }
        else {
            this.headersMap[normalizedKey] = [util_1.normalizeValue(value)];
        }
    };
    BrowserHeaders.prototype.has = function (key, value) {
        var keyArray = this.headersMap[util_1.normalizeName(key)];
        var keyExists = Array.isArray(keyArray);
        if (!keyExists) {
            return false;
        }
        if (value !== undefined) {
            var normalizedValue = util_1.normalizeValue(value);
            return keyArray.indexOf(normalizedValue) >= 0;
        }
        else {
            return true;
        }
    };
    BrowserHeaders.prototype.get = function (key) {
        var values = this.headersMap[util_1.normalizeName(key)];
        if (values !== undefined) {
            return values.concat();
        }
        return [];
    };
    BrowserHeaders.prototype.forEach = function (callback) {
        var _this = this;
        Object.getOwnPropertyNames(this.headersMap)
            .forEach(function (key) {
            callback(key, _this.headersMap[key]);
        }, this);
    };
    BrowserHeaders.prototype.toHeaders = function () {
        if (typeof Headers !== "undefined") {
            var headers_1 = new Headers();
            this.forEach(function (key, values) {
                values.forEach(function (value) {
                    headers_1.append(key, value);
                });
            });
            return headers_1;
        }
        else {
            throw new Error("Headers class is not defined");
        }
    };
    return BrowserHeaders;
}());
exports.BrowserHeaders = BrowserHeaders;
//# sourceMappingURL=BrowserHeaders.js.map

/***/ }),
/* 15 */
/***/ (function(module, exports) {

// This function is written in JS (ES5) to avoid an issue with TypeScript targeting ES5, but requiring Symbol.iterator
function iterateHeaders(headers, callback) {
  var iterator = headers[Symbol.iterator]();
  var entry = iterator.next();
  while(!entry.done) {
    callback(entry.value[0]);
    entry = iterator.next();
  }
}

function iterateHeadersKeys(headers, callback) {
  var iterator = headers.keys();
  var entry = iterator.next();
  while(!entry.done) {
    callback(entry.value);
    entry = iterator.next();
  }
}

module.exports = {
  iterateHeaders: iterateHeaders,
  iterateHeadersKeys: iterateHeadersKeys
};


/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var iterateHeaders_1 = __webpack_require__(15);
function normalizeName(name) {
    if (typeof name !== "string") {
        name = String(name);
    }
    if (/[^a-z0-9\-#$%&'*+.\^_`|~]/i.test(name)) {
        throw new TypeError("Invalid character in header field name");
    }
    return name.toLowerCase();
}
exports.normalizeName = normalizeName;
function normalizeValue(value) {
    if (typeof value !== "string") {
        value = String(value);
    }
    return value;
}
exports.normalizeValue = normalizeValue;
function getHeaderValues(headersAsNative, key) {
    var headers = toWindowHeaders(headersAsNative);
    if (headers instanceof Headers && headers.getAll) {
        return headers.getAll(key);
    }
    var getValue = headers.get(key);
    if (getValue && typeof getValue === "string") {
        return [getValue];
    }
    return getValue;
}
exports.getHeaderValues = getHeaderValues;
function toWindowHeaders(headersAsNative) {
    return headersAsNative;
}
function getHeaderKeys(headersAsNative) {
    var headers = toWindowHeaders(headersAsNative);
    var asMap = {};
    var keys = [];
    if (headers.keys) {
        iterateHeaders_1.iterateHeadersKeys(headers, function (key) {
            if (!asMap[key]) {
                asMap[key] = true;
                keys.push(key);
            }
        });
    }
    else if (headers.forEach) {
        headers.forEach(function (_, key) {
            if (!asMap[key]) {
                asMap[key] = true;
                keys.push(key);
            }
        });
    }
    else {
        iterateHeaders_1.iterateHeaders(headers, function (entry) {
            var key = entry[0];
            if (!asMap[key]) {
                asMap[key] = true;
                keys.push(key);
            }
        });
    }
    return keys;
}
exports.getHeaderKeys = getHeaderKeys;
function splitHeaderValue(str) {
    var values = [];
    var commaSpaceValues = str.split(", ");
    commaSpaceValues.forEach(function (commaSpaceValue) {
        commaSpaceValue.split(",").forEach(function (commaValue) {
            values.push(commaValue);
        });
    });
    return values;
}
exports.splitHeaderValue = splitHeaderValue;
//# sourceMappingURL=util.js.map

/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var browser_headers_1 = __webpack_require__(4);
var impTransport = __webpack_require__(6);
var impTransportFetch = __webpack_require__(7);
var impTransportWebSocket = __webpack_require__(12);
var impTransportXhr = __webpack_require__(9);
var impTransportHttp = __webpack_require__(8);
var impCode = __webpack_require__(5);
var impInvoke = __webpack_require__(11);
var impUnary = __webpack_require__(13);
var impClient = __webpack_require__(3);
var grpc;
(function (grpc) {
    grpc.setDefaultTransport = impTransport.setDefaultTransportFactory;
    grpc.CrossBrowserHttpTransport = impTransportHttp.CrossBrowserHttpTransport;
    grpc.FetchReadableStreamTransport = impTransportFetch.FetchReadableStreamTransport;
    grpc.XhrTransport = impTransportXhr.XhrTransport;
    grpc.WebsocketTransport = impTransportWebSocket.WebsocketTransport;
    grpc.Code = impCode.Code;
    grpc.Metadata = browser_headers_1.BrowserHeaders;
    function client(methodDescriptor, props) {
        return impClient.client(methodDescriptor, props);
    }
    grpc.client = client;
    grpc.invoke = impInvoke.invoke;
    grpc.unary = impUnary.unary;
})(grpc = exports.grpc || (exports.grpc = {}));


/***/ }),
/* 18 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var xhr;
function getXHR() {
    if (xhr !== undefined)
        return xhr;
    if (XMLHttpRequest) {
        xhr = new XMLHttpRequest();
        try {
            xhr.open("GET", "https://localhost");
        }
        catch (e) { }
    }
    return xhr;
}
function xhrSupportsResponseType(type) {
    var xhr = getXHR();
    if (!xhr) {
        return false;
    }
    try {
        xhr.responseType = type;
        return xhr.responseType === type;
    }
    catch (e) { }
    return false;
}
exports.xhrSupportsResponseType = xhrSupportsResponseType;
function detectMozXHRSupport() {
    return typeof XMLHttpRequest !== "undefined" && xhrSupportsResponseType("moz-chunked-arraybuffer");
}
exports.detectMozXHRSupport = detectMozXHRSupport;
function detectXHROverrideMimeTypeSupport() {
    return typeof XMLHttpRequest !== "undefined" && XMLHttpRequest.prototype.hasOwnProperty("overrideMimeType");
}
exports.detectXHROverrideMimeTypeSupport = detectXHROverrideMimeTypeSupport;


/***/ }),
/* 19 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
function frameRequest(request) {
    var bytes = request.serializeBinary();
    var frame = new ArrayBuffer(bytes.byteLength + 5);
    new DataView(frame, 1, 4).setUint32(0, bytes.length, false);
    new Uint8Array(frame, 5).set(bytes);
    return new Uint8Array(frame);
}
exports.frameRequest = frameRequest;


/***/ })
/******/ ])));